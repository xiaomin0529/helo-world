测试github学习喽, 这个是upload上传上去的.  你说什么? 你想修改, 现在确定了吧. 不改了


﻿ubuntu上搭建swift学习环境:
(2016)swift暂时只支持xcode7,ubuntu.(https://swift.org上有), 搭建ubuntu64位虚拟机,copy进swift的tar.gz包,
在里面解压,安装,配置. 最后测试
http://my.oschina.net/kgdugyiy/blog/539998?fromerr=z30sHIFv


Swift标准库方法(只是import swift(应该能省略的吧))
https://developer.apple.com/library/ios/documentation/Swift/Reference/Swift_StandardLibrary_Functions/index.html#//apple_ref/doc/uid/TP40016052

Swift2.2 编程语言官网
https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/TheBasics.html#//apple_ref/doc/uid/TP40014097-CH5-ID309

Swift与Cocoa和ObjC结合 [官网]
https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/index.html#//apple_ref/doc/uid/TP40014216


-------------------------------------------
在playground输一半或小点. , 再按tab可拼全,或列出所有可用变量/方法.

1. hello word
   playground:  print("hello world")
   
   文件: gedit hello.swift 		--新建文件并打开
	print("hello, world")		-- ctrl+S, ctrl+Q退出
   ->swiftc hello.swift 		--编译
   ->./hello					--执行
   
   


-------------基本语法 --------------------------
常量,变量 let a = 10; var b = 11;
	命名: 任何的Unicode字符:  let 图标 = "a"

类型标记: 
	var name:String; name = "xm" 
	var a,b,c,d:Int;  a=1
	pg中报错
	var name:String = "aa"; 多此一举了
	var value:UInt8 = 1;    是设定变量范围的,特殊情况才用, 直接默认Int多好.
	  
	
打印: print(xx)		---------------------试验OK
	print("hello") ,print("a","b","c")    	可连多个
	print("a","b",separator:"-"),   	可选参数1,对多连接加任意分隔
	print("hell0",terminator:"")		可选参数2,是否换行. 设为""

打印时插入变量
	var abc = 10;
	print("this is \(abc)")     ---- this is 10  插入一个变量
	print("---\(abc) is \(abc)")  ----  10 is 10 插入两个变量


注释: 同

分号:  结尾可不加分号,  但一行执行多条语句时用分号分隔:  print("a");print("b")


整数: 分为有符号(-,+,0),无符号整数(0,+)
     UInt8,UInt16, UInt32, UInt64;
     Int8,Int16, Int32, Int64;
	let max = UInt8.max   //为255 or 实验却是-1

    Int , UInt  默认是32或64(按系统位数分)
  
浮点数:  Float, Double

类型安全:   
	变量/常量 类型不可变化. var a = ""; a = 10; 是错误的.  pd上可以var ab=2 下行 var ab=""

不同进制整数:
	二进制,0b开头 let binary = 0b101010;
	八进制,0o开头 let oct = 0o777;
	16进制,0x开头 let 16Int = 0xabcd;

科学计数法: 
	e代表10的倍数或分数:  32e2 = 3200; 32e-2=0.32   实验: e-2后的Double不精准, 打印是0.3200000001


数值分隔阅读: 
	为了方便阅读, 可在数值前加N个0, 或者中间加下划线_来分隔:
	let a = 000123.456
	let 100万 = 1_000_000;
	
数值转换
	整数: 自动转为小的, 除非超出才报错.
		var a:Int8=1; 
		var b = 10 + a;  	---为Int8
		var b = Int(a) + b;  	----为Int
	整数与浮点数:
		var a=1; var b = 0.123;
		var c:Int = 1 + b;错, 
		var c:Double = 1 + b;错  原因是int和double不可以相加.
		var c = 1+Int(b);	-----为int
		var c = Double(1)+b;	-----为double, 看来只能相同类型才能相加.

类型别名: 同OC上吧
	typealias bigInt = Int64;
	var a = bigInt.max;

Boolean: Bool 类型
	var isTrue = true;  //true,false


元组(Tuples):  新类型
	let http404Error = (404, "Not Found")
	let abc = ("haha",111, true, "what",0.123)

	//就是一组单个单个的值, 放在括号里. 没有特别的意义, 操作就好了.
	http404Error的类型就是(Int,String). 值就是(404,"Not Found")

	var bl = (404,"Not Found") == http404Error;  //结果为true 

  分解元组:
	let (XmStatus, XmMessage) = http404Error;      //即分配两个常量XmStatus,XmMessage,分别赋了值
	XmStatus = 1; XmMessage = "Not Found"
	print("\(XmStatus)")     //打印就说明情况, 是分配了常变量.

	let value1 = http404Error.0;
	let value2 = http404Error.1;
	let bl = XmStatus==value1;  //返回true
  分解部分:
	let (XmStatus,_) = http404Error;   用下划线忽略不想要的部分
	
  定义时各部分赋名称:
	let http404Erro = (status:404, msg:"Not Found");
	

可选项(Optionals) --- 新语法,OC没有的
	它代表: 可能有值, 也可能根据没有值(相当于nil)
    如:
	let a = "10" ; let b = "10a"
	let c = Int(a); let d=Int(b)   ---String转化为Int

	此时,c和d是可选项,  c的类型是 Int?=10, d的类型是 Int?=nil

    声明可选项类型:
	var/let a:Int? = 10;  
	var/let b:String? = nil;
	
	var c:Int?;   //不能用let; 不加为nil
	c = 10;	 
	print("\(c)")	---> Optional(10)
	
nil -- 联系Optional
	nil只能赋给Optional的常量或变量. 
	ObjC中nil是空对象的指针, swift中不是指针,它是某一类型的值的缺乏.
	nil不只赋object, 基本类型也可nil.

  是否为空:判断
	if Opt1 == nil {}

  绑定可选项: if, while
	if let constNm = Int(opt1) {} else {}

  隐式打开可选项:
	即将Optional类型化为变通变量/常量
	let opt:String? = "";
	let str:String = opt!;	//可选项后边加感叹号 !
	
	注意error! 只有Optinal可为nil. 当!前的opt是空时, 则打开会报错.

	另外: let abc:String! = ""  这个是打开的,和普通常量一样, 多加String!有意义么, 有啊

  转换时?!错误的解决
	let a:Int = Int("2")    --Int vs Int?型, 此时会报错
	let a:Int = Int("2")!   --加个感叹号就OK啦 


异常捕获
    1.方法抛出throws
	func methodName() throws {
	
    2.捕获
	do {
	   try 某个方法()
	   //继续代码
	} catch Error.错误1{
	   //处理1
	} catch Error.错误2 {
	   //处理2
	}

Assertions声明: 方便调试

   let age = 30
   assert(age<30, "你已经奔三啦"); 	
   执行到assert时,如条件false直接报错终止app. 符合则继续执行
	
   注意! assert在代码优化时是要disable的, 比如xcode中要配置


===============2 基本操作 ========================================
1. 赋值 略
	var (x,y) = (1,2)
2. 算术运算 略
	String+String可行了.  "Hello,"+"world"
	可浮点磨: 10%3.3

3. 比较运算, 三目运算 同, 略

4. Nil聚合操作: a ?? b ?? c
	var a = 3
	var b:Int
	var c = b ?? a	//??两边必须有空格, 
	//如果b为nil, 则c=a. 

5. 范围操作符: a...b
   表示一个范围,常用在for循环中
   for index in 1...5 {  index...}

6. 半范围操作符: a..<b 同上但不包括最后的b
   for i in 0..<count { i}

7. 逻辑运算符 略 或且非相同


==============3 字符串 与 字符=====================================
"hello"+"\(15)"

1. 初始化String
	var str = ""
	var str = String()

2. 是否为空字符串(不是nil)
	str.isEmpty   不带括号

3. 拼接
	"a"+"b"
	str+="hello"	//let声明的常量不可以拼接
	str.append(x)

    拼接数字时用\()转换
	str+= "\(  10000 )"


4. 字符串是'值类型' -- not指针类型
    即当传给方法时, 它是copy去的. 
    不用担心在方法/block外string改变影响里边, 


5. 字符处理
    分解成字符
    for c in str.characters { c}
    str.append(char)

    声明单字符
    let c:Character = "A"  --不是单引号
	注意: Int(s)参数只能是数字或String. 而不能是character,会报错
	Int(String(char)) 解决

    字符串长度
	str.characters.count    --无length

6. Unicode特殊字符
    let special = "\u{1F496}"  --都是"\u{}"的

7. 字符串索引
	str.startIndex
	str.endIndex   //返回Index类型,而非数字
	代表首尾的字符. 然而
	Index.successor()是后一个字符, 返回值仍是Index
	Index.predecessor()是前一个字符
	Index.advancedBy(i)是向后第几个字符, 负数则是向前数

   如   let str = "hello"
	str[str.startIndx]  为 h
	str[str.endIndex]   越界错误
	str[str.startIndex.successor()] 为e
	str[str.endIndex.predecessor()] 为o 最后位
	str[str.endIndex.advancedBy(-3)]

   索引集合   str.character.indices
	for index in str.character.indices {
	    print("\(str[index])")
	}

8. 插入/删除字符
    str.insert("A", atIndex:str.endIndex)
    str.insertContentsOf(str2.characters, at:str.endIndex)

    str.removeAtIndex(index)
    删除范围
    let range = str.endInex.advancedBy(-6)..<str.endIndex
    str.removeRange(range)

9. 比较字符串 ==
	if str1==str2 {}
	if char1 == char2 {}  //字符与字符串比较会报错

10. 前缀后缀检查
	hasPrefix(""),  前缀, 
	hasSuffix(""),  后缀

11. Unicode表现
	.utf8		---String.UTF8View 
	.utf16		---String.UTF16View  
	.unicodeScalars	  
	🐶🐶
    utf8是UInt8的集合,一个Unicode包含1~多个UInit8
	let str = "\u{1F436}"
	for unit in str.utf8 {
	   print("\(unit)")
	}   ----输出240 159 144 182,  表示它由4个字节组成. 普通A则1个
  
    utf16是UInt16的集合,一个Unicode包含1~多个UInit16 (但容量大了,数量变少)
	 "\u{1F436}"这个狗头图标, 在utf16里只要两个单元就可.

    unicodeScalars属性是UnicodeScalar类的集合,  UnicodeScalar.value返回21bit值, 
	表现为UInt32位的数字. 比utf16更大了.
	"\u{1F436}"这个狗头图标只要一个单元

    另: String的每个unicodeScalars 类似单字符,可拿来用. 


====================   集合类型 =========================================
Array, Set, Dictionary   --都是struct类型的,传递都是copy的. 不同于ObjC中是类对象,引用类型

都是Mutable啦.  可直接增删改了.

1. Array

1.1 新数组
	var arr = [Int]()	
	var arr:[String] = []	--空数组(必须声明类型)
	var arr = [1,2,3] 	--初始值的不用加类型
	arr = []		正确

	var arr = []		错误, 无初始值无类型
			

1.2 增删改
     增加
	append(x)
	insert(x,atIndex:i)
	arr += [e1,e2]
	arr = arr1 + arr2;      --元素类型必须一样
     删除
	dropFirst/Last([i])     返回一个去掉头/尾[第几个]的新数组,连index也去掉了. 如dropFirst()会从1开始.
	removeFirst/Last([i])	--返回删掉元素的index
	removeAll/Range()
     修改
	arr[i] = newEle		  --直接修改arr元素
	arr[i...j] = [a,b,c,d]	  --有时range <> 元素数, 则按少的来替换. 自己操作体会
	reverse() 		  --返回倒序后的新数组
	sort(

1.3 各种查
    查元素
	arr[i]
	first/last
	popLast()	--pop一次,数组减少1个	

	for i in arr {i}
	forEach(
	enumerate()	-- for  (index,value) in arr.enumerate() { i,v}
    查属性
	count		数量
	indexOf(e)	索引
	startIndex	-- 开头index有时不是0
	endIndex
	contain		包含么
	isEmpty		空否


2. Set 暂略吧
  特点: 两个Set的 交集, 并集, 补集等比较有用.

3. Dictionary
3.1  创建新字典
	var dic = ["a":100,"b":200]  	---{}变成[]了
	var dic = [String:Int]()	---k,v之间是冒号:
	var dic:[String:Int]  = [:]	---空字典里有冒号
	dic = [:]

3.2  增删改
	dic["key"] = value2/nil    --insertOrUpdate, value可为空
	dropFirst/Last(Int)  返回一个去掉头/尾[第几个]的新字典,连index也去掉了. 如dropFirst()的keyArray会从1开始.
	updateValue( forKey:) 
	
3.3  各种查
	for (k,v) in dic { k,v}
	for k/v in dic.keys/values { k or v}
	enumerate()
	popFirst()

	count
	isEmpty
	contain(


====================== 控制流  =================================
1. for循环
   for i in 0...5 {
   for _  in 0..<5 {   不需要索引i时用 _ 代替
   for el  in array {
   for (k,v) in dic {

2. while循环
2.1 while loop 同
2.2 repeat{ } while 	 ---同 do{} while


3. 条件判断
3.1  if else if  else
   if除条件判断外, 还有赋值判断(值绑定), 即nil判断
	var a:Int? = 10
	if let b=a { 此时为真}	 ---值绑定的常/变量scope只在if内部.

	a = nil
	if let b=a { nil了则为假 }

3.2 switch
	switch value {
	case  v1: xxx		---v1可以是多个值! break是可选的;
	case  v2: xxx
	default: xxx
	}
     多个值:
	switch "e" {
	case "a","b","c","d": print("")
     区间:
	switch index {
	case 1..<5:
	case 5..<10:
     元组Tuples:
	let tp = (1,1)
	switch tp {
	case (_,1):
	case (1,_):
	case (0...2,0...2): 	--区间...
     值绑定
	let tp = (2,0)
	switch tp {
	case (let x,0):
	case let (x,y):		---let的常/变量的scope只在switch内.

	注意: value区分大小写的! 不像C里a和A相同

4. where
    多用于在 值绑定 后对局部常/变量进行 条件附加; 还有do catch后:catch 条件 where xxx {}
    值绑定+where = 不为空, 且where正确

    var a:Int? = nil
    if let b=a where b>=3 {
    
    let tp = (1,1)
    switch tp {
	case let (x,y) where x==y :

5. 控制转移语句
	continue
	break
	fallthrough   
	return		--Func中
	throw		--异常处理

    continue, break 同
    fallthrough  当条件符合并执行后, fallthrough会直接执行到下一种条件判断或default里
	if 1=1 {
	   fallthrouth
	} else if(2=2)
	    //会继续执行到这里

 
    命名循环: 给for/while命名, break/continue等定向
	firstLoop: while ...{
		break firstLoop


6. guard 控制
	同if语句, 但只能是 if .. else {}
	guard let tmp = cont1  else {

	}
	为了提高代码可读性. 相比较if{}else{}或者if !condition

7. 自带的[API可用性检查]
      内置了API可用检查, 使用if/guard语句来有条件地执行代码, 确保某系统版本能使用某APIs
	if #available(iOS 9, OSX 10.10, *) {	  --iOS 9,OSX 10.10版本或later
	    //使用iOS9的API
	} else {
	    //使用更早期的API
	}

    在#available()参数中,用多个逗号区分不同平台如iOS,OSX,watchOS等,加空格后是系统版本,可细分如iOS 9.3,
	表示必须是iOS 9.3版本或之后版本.  *表示其他平台.


======================== 函数 Function  ========================================

1. 定义,调用函数
	func add(a:Int,b:Int)->Int {
	    return a+b;
	}
	func定义, (参数名:类型,参数2:类型), ->返回类型

	let c = add(1,b:2)	--注意:首参永远不加别名,第二个以后都要加别名, 否则报错

2. 方法参数及返回值

     省略第二参数名:
	func add(a:Int, _ b:Int)...
	add(1,2)		-- 第二别名前加_号+空格(_b为完成别名), 调用时就免别名啦

 
     无参无返回值函数:
	func abc() {}
     多个返回值:
	func abc() -> (a:Int,b:Int) {	   -- 2个或更多个
	    return (1,2)
	}
	let (a,b) = abc()   -- 则a=1,b=2

     数组,字典,可选项型参数,返回值
	func convert(strArr:[String])->[Int?] {     -- 传入数组,返回数组(转换的是可能为空的)
	    var numArr:[Int?] = []
	    for i in strArr {
		numArr.append(Int(i))
	    }
	}
	let numArr = convert(["1","2"])
       字典:
	func abc(dic:[String:Int]) -> [String:Int] {
	    var dic2:[String:Int] = [:]	    --传进来的dic是let常量, 不能修改所以重声明dic2
	    for k in dic.keys {
		dic2[k] = dic[k]! + 1	    -- ! 号因为取value有可能是空的. 前面不是?号, 后面?的要加!号.
	    }
	    return dic2
	}
	let dic = ["a":1,"b":2,"c":3]
	let dic2 = abc(dic)		--值 a:2,b:3,c:4


    Optional Tuple  -- (Int,Int)?
	不同于(Int?,Int?), (x,x)?这种是整个的可选的, 即(x,x)是完整结构, 要么有值,要么没值(如同结构nil)

	func abc() -> (Int,Int)? {

    额外的参数名:  即参数名word-->词组
	func abc(input value:String, and second: [String]) {
		//value, second	使用后面的字,作为局部常量
	}
	abc(input:"xxx", and:"222")	//第一个单词在调用时输入的
	
	
    默认参数值: 
	方法声明时有默认值, 调用方法可不传值
	func add(a:Int=1,_ b:Int=2) -> Int {
	    return a+b
	}	
	let c = add()	--值为3
	
	//问题: 如何参数1默认, 参数2传入呢?

    可变数目参数:  ...号
	如同传入数组一样,  Double... 和[Double]差不多
	func test(aa:Int...) {
	   for i in aa { 
	}
	test(1,7,10,555,888)
	
    可修改参数: inout
	默认所有参数都是常量, 方法内不可修改之. 但用inout修饰则可修改,包括基本类型
	inout传入的参数只能是变量.
	     不能是常量,不能是文字串,不能加默认值, 不能是可变数目参数

	func abc(inout a:Int, inout _ b:Int){
	    a = 2
	    b = 3	--方法内修改参数值
	}
	var a=1    
	var b=2
	abc(&a, &b)    --则a=2,b=3了. 必须加& 表示引用

	
3. 函数类型 (新特性)
     根据参数及返回类型 描述函数类型:
     func abc(a:Int,_ b:Int) -> Int {}  类型为 (Int,Int) -> Int
     func abc() {}  		       类型为 ()->Void   --大写的Void


   函数类型的使用
	跟其他类型一样可声明常量变量,数组, 作为参数,作为返回类型... 
	var bcd:(Int,Int)->Int = abc
	let c = bcd(2,3)

	解释说明: 声明一变量名叫bcd,它是一种函数类型,包含xx型参数xx型返回值, 
	   它现在指向abc()这个函数. (bcd和abc是同一种类型)

	多个函数,只要类型一样, 可重分配给函数类型变量
	bcd = aaa	-- 类型一样,但实现不一样. 照常分配.


   函数类型参数: (如同函数传递, 但不指哪个函数, 只是函数格式传递)
	func add(a:Int,_ b:Int) -> Int { return a+b }
	func multi(a:Int,_ b:Int) -> Int {return a*b }

	func mathTest(mtd:(Int,Int)->Int,_ b:Int,_ c:Int) {
	    return mtd(b,c)
	}
	
	let addResult = mathTest(add,2,3)	--2+3=5
	let multiResult = mathTest(multi,2,3)	--2*3=6

   返回类型
	func chooseType(a:Int) -> (Int) -> Int {
	    可返回同级其他func
	}

	func aaa(a:Int)->Int { return a+1 }
	func bbb(a:Int)->Int { return a-1 }
	func chooseType(f:Int)->(Int)->Int{
	    return f>0 ? aaa: bbb 	---三目的bool后不能直接加? 要有空格
	}
	let num = chooseType(1)(3)  -- 3+1=4
	let num = chooseType(-1)(3) -- 3-1=2


   嵌入函数
	嵌入后对外是隐藏的. 嵌入函数仍可当作返回值被所在函数返回
	func outter ...
	    func inner1
	    func inner2
	    return true?inner1:inner2
	}
	

============== 闭包 ==================================
 闭包是功能体block(块), 可被传递和使用.  类似于C中的block块,java中的匿名方法
    
 函数也是闭包:
    全局函数  带名字的闭包, 不能捕获值
    嵌套函数  带名字的闭包, 可捕获所在函数内的值
    闭包      无名字, 轻量级语法, 可从上下文中捕获值.


1. 闭包表达式
    { (a:Int,_ b:Int) -> Int  in 
	//代码
	return xx
     }
  无参无返回包:
     { ()->Void in 	--大写Void
	//xxx
      }

  使用示例:     	-- 传入函数类型Func Type的地方可传入闭包
	func aaa(a:Int) -> Int {
	    return a+a
	}
	func mathMtd(mtd:(Int)->Int) { 
	    let c = mtd(3)
	    print("\(c)")
	}
	mathMtd(aaa)    --- 3+3 = 6	传入已声明的方法

	mathMtd({(a:Int)->Int in 
	    return a*a
	})		--- 3*3 = 9	传入闭包

	其他: array.sort(funcType)函数

   无参无返回闭包
  	func say(){  print("hello") }
	func whoSay(mtd:()->Void) {	---Void 首字母大写
	    mtd()			---要带括号
	}
	whoSay(say)
	whoSay({ print("ni hao") })	---省略版. 完整是{ ()->Void in  print("") }



2. 推理参/返回类型: (省略类型, 但表达式要在同一行 inline)

	mtd({a:String,b:Int -> Int in  return  value }) 
	   { a,b  in  value }			--省了:参数类型,返回类型, return字

	参数/返回类型可以省略, 尽量省略. code好看
	省略return时 必须要语义明确简单, 尽量加上吧


    速记的参数名: (写在同一行)
	有参数时, 连参数名也省略, 而代以$0,$1,$2 等(按顺序代替)
	mtd({ aaa:Int,jlkj:Int,oija:Int -> Bool in  return aaa + jlkj + oija})
	mtd({ $0+$1+$2 }

    更短的写法
	sort({ $0 > $1 })
	sort( > )	---连大括号都没有了. 

	是特定的方法, String类的 大小于><可代表一个函数Func, 所以可以替代{ }的

3. 尾部闭包
	当此闭包是函数最后参数,且闭包很长时. 很有用
	
     示例:
	method({ xxx })  可以写成
      
	method(){ xxx }    ---即从()内变为()外了. 要注意的
	method {  xxx }	   ---仅闭包一个参数时, ()都可以省了.



4. 捕获值: (重要特性)
     能从上下文中引用/修改常量和变量, 即使原先的常量/变量后来不存在了.
     嵌套函数(也是闭包),能从outer的函数里取值使用.	
	

     嵌套函数,,作为闭包, 引用参数和局部变量. 最后return, 拿来用


     捕获的不可变值的话, 则会是copy的. 如常量,字串
     --如定义闭包作为类成员, 此闭包又捕获类中其他成员或类实例, 则陷入strong循环了. (后面ARC中会讲)



5. 不泄露的闭包参数 @noescape --为了优化编译
	保证在函数return前 闭包参数会释放掉.
	
	只在[方法体内] 不引用外部值时可加@noescape, 引用外部值加@noescape会报错.
	即方法体内只能使用局部变量,参数,和闭包参数
	
	escape的方法的闭包体内, 引用类变量要加self.
	noescape的闭包体内, 引用类变量免加self.
	
	像sort()方法可加@noescape,不引用外部值嘛
    示例: 
	var xxx
	func escapeMtd(closure:()->Void) {
		xxx;
	}
	func noescapeMtd(@noescape closure:()->Void) {
		closure();
	}
	
	class AA {
		var x = 10
		func doSomething() {
			escapeMtd { self.x = 100}	--普通样子, 用这个就好了.
			noescape { x = 200}			--免加self了,  没太大用
		}
	}
	
6. 自动闭包
	用{}包围一个表达式 作为闭包. 
	它无参数, 把表达式返回值作为自己的返回值. 可作为函数参数传递, 或赋值给常量/变量
	
	{}声明时不执行, 只在调用(即有())后才执行结果.
	示例:
		var arrar = [1,2,3,4];
		let autoClosure = {  array.removeAtIndex(0) }
			--这时只是声明, remove并未执行.   数组还是4个. autoClosure只是一个函数声明一样
			
		let value = autoClosure()   
			--执行闭包代码, 数组remove了, 而闭包返回remove后返回的值. value=1

		同理函数可传递自动闭包
		
		注意: 过度使用自动闭包会让代码难阅读
		
7. 自动闭包 + escape
	@autoclosure()来明确自动闭包 能否使用外面值
	func abc(@autoClosure(escape) closuer:()->Void) {
		closuer() + xxx
	}
	abc({ self.xxx = 100})
	
	还有 @autoClosure(noescape)
	
	
	
	
8. 追加, 可选闭包
	()包起来
	var a:(()->String)? 		-- a:nil
	a = {return "xx"}
	let str = a
	
	区别于闭包的可选参数
	var a:()->String? = {
		return nil
	} 
	let str = a		

不同于block在方法体中直接{}, 闭包要么是嵌套函数供调用, 要么{}赋给FuncType的常量/变量,要么作为参数.
	只有作为参数可以是无名的(方法体中还会调用参数名的), 嵌套函数和赋值FuncType都有名字


======================== 枚举  ==================================
enum Direct {
	case Top
	case Left
	case Right
	case Bottom
}
或者写成一行
enum season {
	case Spring, Summer, Autumn, Winter
}
综合
enum Test:Int{
	case A=1,B,C,D,E,F 				--设置原始值的话(A=1),声明时加类型(enum xx:Int)
	case Jack,Tom,Hellen 
}



--不同于C,ObjC的枚举, 此中的枚举值不会对应Int的1,2,3...
   值的类型就是所属枚举名的类型:  Top是Direct类型的
   
1. 枚举的使用
	let dir = Direct.Top     --  dir常量 是Direct类型, 值为top
	
	print(dir)				---直接当string输出了
	
	dir = .Right			---再赋值时, 可直接 .XXX, 因为上次类型已经定了
	
	
2. 用if else ; switch{}语法来匹配枚举
	let dir = Direct.Top
	switch dic {
		case .Left:  xxx	-- 点号前面一定要有空格, 否则报错
		case .Right: xxx 
		case .Top :  xxx
	}
	if dic == .Top {		-- 点号前面一定要有空格, 否则报错
		print(dic)
	}
	

3. 关联值:
	先关联类型, 赋值时再关联值
	enum 二维码 {
		case 条形码(Int,Int,Int,Int)
		case 二维码(String)			---定义了枚举类型
	}
	var abc = 二维码.条形码(876,12,4,111)
	switch abc {
		case .条形码(let a,let b,let c,let d):
			print("\(a)...")
	}
	
	或者
	case let .条形码(a,b,c,d):


4. 原始值rawValue
	enum除了保存关联值外, 还可以保存默认值(原始值)
	enum Num:Int {
		case A=10,B=20,C=30				--设定原始值时, enum声明要加类型
	}
	
	let c = Num.A    -- 此时c 仍是枚举值 A
	let d = Num.B.rawValue   --调用原始值  d = 20
	
	
	隐式原始值
	enum Num:Int {
		case A=1, B,C,D,E,F    --B,C,D..会默认=2,3,4,5 
	}
	enum Name:String {
		case 孙悟空,Jack,Hellen	  --rawValue就是"孙悟空","Jack"啦
	}
		
		
	从原始值取枚举值:
		let num = Num(rawValue:3)  ---num为Num? 类型的枚举C.
		
		
	递归枚举: indirect 
		先递归声明,  再多层set, 进函数递归分解. 还不如直接用函数呢
		
		indirect enum DiGui {
			case Number(Int)
			case Add(DiGui, DiGui)     --这里就引用自身了
		}

		
============ 类 与 结构体 ==============================

1.不同于OC, 要.h,.m创建类, swift中声明类于单个文件中
2.通常一个类的实例是对象,  swift中的类/结构体 更像函数体.


1. 类 vs 结构体 的比较
    共同点:
		1.定义属性&方法
		2.定义下标
		3.定义初始
		4.扩展
		5.实现协议
		
	类特有的:
		1. 继承自其他类
		2. 运行时检查类型
		3. 释放资源
		4. 引用计数让类实例有多个引用
		
	结构体是值类型, 类是引用类型.  即传递时struct是copy的,object是retain的.
		
		
		
2. 声明 
	class  Person {		--首字母要大写, 以统一于String,Int
		var dog = Dog()
		var name:String?		--注意 是:号
		var age = 30
	}
	struct Dog {		--首字母大写
		var name = "旺财"
	}
	
	实例:
		let dog = Dog()
		let person = Person()		--实例化
	
	
	访问类/结构 属性和方法 
		person.name = "Jack"		--Setter
		print(person.dog.name)		--Getter
		
		注意: 不同于ObjC, swift中的结构体属性可以直接设置:  frame.size.width = 300
		
		
	结构体初始设置
		let dog = Dog(name:"小黑")		--只在struct能这样, 初始时设置成员值
		
		
		
3.  结构体&枚举是值类型, 类是引用类型: 
	  (即copy与retain的区别)
	  struct Size{
		var width=10
	  }
	  class Person {
		var name = "xiaomin"
	  }
	  var s1 = Size()
	  var s2= s1
	  s2.width = 15 					--只在seting时才体现出两者是不是同一个.
	  print("\(s1.width),\(s2.width)")	---10,15 两个结构体不相同
	  
	  var p1 = Person()
	  var p2 = p1 
	  p2.name = "Jack"
	  print(p1.name+","+p2.name)	--Jack,Jack  两个对象是同一个
	
	
4.  完全一致操作符 ===,!==
	只能作用于 类对象判断(引用类型的),  结构体不能用
	
	let b = p1===p2 
	let b = p1 !== p2   -- !号前要有空格!
	
	--注意:  当使用!==号时,左边一定要有空格.  p1!==歧义为: p1! == 即p1为带?型.
	
	
5. 指针号: 无 
	C,ObjC中定义引用型变量时, 要加*.  swift也有指针, 但定义引用型变量和值对象一样形式.
	
	
6. 如何选择 类和结构体
	因一个传递值,一个传递引用, 参考下面决定某数据结构 如何定义:
		1.struct主要目的是压缩简单数据类型.
		2.struct不需要从其他类型中继承属性or行为.
		
	struct主要场景:
		1. 几何学形状, 使用各种数值,公式
		2. 范围range, 比如start, length
		3. 3D上的位置点,  x,y,z...
		
	在其他情况下, 自定义数据结构主要是Class, 而不是struct
	
7. Copy的常用数据类型
	String,Array,Dictionary 等都是由结构体实现的.  所以传递字串,数组,字典都是Copy值的.

	//ObjC中的NSString,NSArray,NSDic则都是引用类型.
	
	
	
=================属性 和 方法 =============================================
  属性分为储存型 和  计算型属性
  
1. 储存型属性
	是一个常量or变量, 储存着对象or结构体; 可用let,var 声明 
	
	常量结构体:
		let size = Size(width:10)
		size.width = 20  	--报错,  常量struct自身和内部值都不可修改
		
		--不同于常量类实例, 引用型.  它引用地址不可再改, 但可改引用类的内容的
		let p2 = Person()
		p2.name = "Tom"		--- 对象内容可改
		p2 = p1				--- 引用地址不可改的
		

	懒储存属性: lazy
		lazy修饰, 声明懒属性时,不会立即创建对象, 而是只在使用到时才创建. 可以避免无效地浪费资源
		1. 对象初始化依赖'外部原因', 比如导入文件,读取文件, 网络. 
		2. 或者对象初始化复杂,需要很长时间的.    确保在需要它时再执行
		
		class Person {
			lazy  var work = Work()
			var name = "xxx"
		}
		let p = Person()		--初始化, 此时Work()不会执行
		p.name = "abc"
		p.work.execute()		--此时work才初始化,再执行.
		
		注意: lazy属性线程不安全
		
	属性与成员变量:无
		ObjC中除了属性还可以定义成员变量来储存值和引用.
		swift中统一成属性.
	

	
2.  计算型属性:(特性)
	它不保存值, 却提供getter来返回+可选的setter设置其他属性. 
	因值不是固定的, 只能用var来声明   —-实质很像方法啊
	struct Size{
		var width=0,height=0		---  计算型属性不分类型的. Int也行
	}
	struct Abc {
		var length = 50
		var aa:Size {				--计算型只能在struct,class,enum中定义. 不能playground直接定义
			get {					-
				return Size(width:length,height:8)
			}
			set(st) {
				length = st.width		--可以设置结构中其他属性
			}
		}
	}
	var abc = Abc()
	let aa = abc.aa 		--aa属性没有储存值, 但通过get方法返回了值.
	let len = abc.length		—50
	abc.aa = Size(width:60,height:0)	—setter一个完整Size
	let len = abc.length		—60
	
	--set方法简写:
		set {				  --省略了括号和参数
			newValue.width	  --默认是newValue来代替参数
		}
		set {
			self.aa = newValue		--[追加说明] 设置自身属性,self是struct自身,.aa则是计算型属性自己.
		}
	
	只读型计算属性:（即无法set）
		只剩getter,就可省略直接return
		var aa:Double{
			return 0.123
		}
	
3. 属性监听 (观察者)
	监听和反应属性值的改变. 监听任何时候的值设置, 即使设置了相同的值.
	
	1. 加在自定义的储存型属性上, 除了lazy属性. 自定义的计算属性的set中可设置监听,因此no need设置监听.  
	2. 加在继承来并重写的储存型or计算型属性.
		父类中的属性监听在子类初始化时会自动调用.

	监听类型:
		willSet(newPara){}		传递自定义名字的常量参数, 不加参数则默认是 newValue
		didSet(oldPara){}		传递自定义名字的常量参数, 不加参数则默认是 oldValue				

	示例:
	class Person{
		var name:String = "xiaomin" {
			willSet(newName){
				print("马上要用\(newName)来替换名字\(name)了")
			}
			didSet {			--不加()和参数, 默认为oldValue.   计算型属性的set很像,所以彼也能做监听
				print("现在名字为\(name),之前名字是\(oldValue)")
			}
		}	
	}
	let person = Person()
	person.name = "hahaha";		--- 每次都是will一句,set一句
	person.name = "jack"
	
	注意: 如一个加了监听的属性作为inout参数传进函数里, 则will/didSet总是被调用(即使方法体中没set参数), 
			因为函数结束后值会被重新写回属性里!
		示例: 
		    func test(inout name:String) {
				print(name)
			}
			test(&person.name)
			
		---结果为: print jack ; 最后调用willSet和didSet 


4. 全局和本地变量
	上面[计算型属性]和[属性监听] 同样适用于全局+本地变量.
		
	全局变量, 定义outside 函数,方法,闭包, 类型上下文.
	本地变量  定义inside 函数,方法,闭包, 类型上下文.
	
	全局变量/常量不同于lazy储存型属性, 它一直是lazy的, 不用加lazy修饰.
	本地变量never不能设置为lazy的.
	
	
	
5.  类型属性: static
	 类型属性belong类型自身, 不属性实例. 

	类型属性声明时必须有默认值(因无法通过实例化赋值);
	储存型类型属性在第一次访问时是lazy初始化的.  能保证只初始化一次, 多线程也不怕了. 也不需要加lazy修饰的
	
	定义范围:
		类型属性可被定义在类,结构,枚举中
		struct Abc {
			static var storedTypeProperty = "hello"		--储存型类型属性 
			static var coputedType:Int {				--计算型类型属性
				return 10;
			}
		}
		
	查询和修改类型属性
		同其他语言,  类型名直接调用  let str = Abc.storedTypeProperty   
		--用实例调用会报错
		
	
================== 方法 (区别函数)========================================
在类,结构,枚举中定义的函数就是方法.
	与其他语言区别是: swift能在struct,enum中定义方法
	
1. 实例方法
	同其他语言:(struct,enum定义的除外)
	
	self (实例方法):
		对应当前实例(同java中的this, 不同于ObjC)
		func setName(name:String) {
			self.name = name
		}
		
	值类型中修改属性的实例方法: mutating
		struct,enum是值类型, 赋值是copy的. 当实例方法会修改属性值时, 到底是copy呢,还是啥呢
		struct Dog{
			var name = "wang cai"
			mutating func setName(name:String) {self.name = name}	--值类型单纯func中修改属性会报错
		}
		
		mutating型方法, 在方法结束后会生成全新的实例并替换原实例.  不担心copy的问题了
		var dog = Dog()			
		dog.setName("da huang")		---因为方法会替换原对象, 所以声明时不能用let,  用var 

		
	赋值给self:
		mutating方法中给self赋值新实例
		setName(name:String){
			self = Dog(name:name) 			--name:name 左边声明名, 右边变量名
		}
		
		enum Color {
			case red, green, yellow
			mutating func next() {
				switch self {
					case red: self = green
					case green: self = yellow ......
				}
			}
		}
		var cl = Color.red 			--enum的实例方式
		cl.next()
		print(cl) 
	
	
2. 类方法 static/class 
	结构,类,枚举用static,  类也可以用class修饰方法
		class Person{
			static func abc(){}
			class  func say(){}		--
		}
	
	self(类方法):
		类方法中的self代表类型自身,而非实例.  所以self只能调用static属性.
		static var name = "hello"
		class func say(){ print(self.name) }
	 
		Person.say() 		--打印hello
		
 
	即类成员不能用于实例中:
		普通方法不能调用静态成员, self/类名都不行.
		
		
=================下标 subscript==========================
作用: 访问集合型成员的快照(只能用于集合).  定义在类,结构,枚举中

struct Grid {
	var grid:[Double]
	subscript(row:Int,col:Int) -> Double {		--实质和方法一模一样. 就是最后访问形式是类型名+下标
		get {
			return grid[row+col]
		}
		set {
			grid[row*col] = newValue		--newValue同监听,计算型属性
		}
	}
}
	var gg = Grid(grid:[1,2,3,4,5,6])
	gg[1,2] = 20 ;gg[2,2] = 43 			--此set没什么意义呀,没设置到成员
	let cell = gg[2,3]					---下标不能超出集合现有的, 否则报错

	
---除特殊情况集合处理, 正常情况下集合操作已足够,再加些方法处理.  滥用下标会影响代码阅读





================= 继承 (Class独有)============================================
swift没有默认继承的基类(如Object).  所有类(无继承)都可以是基类

1. 继承 
	class Son: Father {			---继承用:号
	}

	
2. 重写:override
	可重写实例/类方法&属性, 下标 , 声明前都要加override
	方法:
		override func say() {  }
		
	属性:
		属性只能重写 
			1.计算型属性的get,set; 
			2.添加监听willSet,didSet .  --不能重写储存型属性
			
		override var name:String {
			return "hahah"		--get(). 重写set也要重写get, 如不想改变get可return super.属性
		}
	
	---重写属性,下标即是重写它们的方法(get,set等)
	
	
3. 调用父类成员: super
	super.mtd()		
	super.property
	super[1,2]	  --下标
	
	
4. 防止重写:final
	预防重写,可加在方法,属性前,或者class前:
	
	final class Xiaomin{
	}
	
	class Father {
		final init(name:String){}		--可防止构造方法重写
		final func doFatherWork(){}
	}
	
	
	
================= 初始化 =================================================
是类,结构,枚举实例化的过程, 包含对储存型属性赋初始值,和一些必要的设置.

1. 初始化方法:init() 
	定义init()方法, 它创建新的实例对象却不返回对象(不同于ObjC)
	
	--类还可以实现反初始化(deinitial), 实现对象销毁前的清理工作. clean up 

	struct Rect{
		var width:Int
		var height = 100 		---
		init() {
			width = 80			---默认值 & 初始化时 都不会调用属性监听 Observer
		}
	}
	let rect = Rect() 			--- 实例化时, 就会调用init()
	let width = rect.width 		--  此时有值的


2. 自定义构造方法:init(arg)
	struct Rect {
		var width:Int
		init(fromA a:Int) {
			width = a+a
		}
		init(_ b:Int){
			width = b*b
		}
	}
	let rect = Rect(fromA:100)		-- 100+100 		此时调用,外部参数名字是必须的.
	let rect2 = Rect(200)			-- 200* 200		使用了 _ 后, 外部参数名不加
	
	
3. 可选项属性 
	struct Rect {
		var length:Int?			--即无默认值, 也未在init中初始化
	}
	
	let rect = Rect()
	rect.length = 10			--带?的默认值是nil, 意义就是实例上可为空.  实例化后可选赋不赋值


4. struct的成员逐一初始化(默认)
	struct Rect {
		var width:Int,height:Int 
	}
	let rect = Rect(width:10,height:10)   --struct默认有init(arg). 参数数==成员属性数
	
	
5. 值类型的初始化代理 Delegate
	一个构造方法调用另一个构造方法, 称之为初始代理...  (只能用于值类型哦)
	
	struct Color{
		var red,green,blue:Double 
		init(r:Double,g:Double,b:Double){
			red = r;...
		}
		init(white:Double){
			init(r:white,g:white,b:white);	--白度方法直接调用RGB方法
		}
	}
	
6. 类继承和初始化:
	swift提供两类初始方法确保all储存属性被初始化: 
		指定初始,便利初始
	
	init() { }				--指定初始 
	convenience init() { }	--便利 
	
	区别:  
		1.指定和便利都能被继承, 即子类中都能调用super中两种初始方法.(记住是调用不是说重写)
		2.指定init()中必须初始化self全部储属性;
			如有父类,还必须加super.init初始化父实例.
			指定init可被子类重写(可以被override成便利构方), 也能重写super中的指定init.
		3.便利init不能调用super.init, 只能调用self.init()(指定or便利), 
			便利可重写super.init()(因参数相同),此时self.指定init与便利重写的super.init参数不同.
			将super.init重写成便利后,孙类就不能再重写此方法了. 断代了.
			
	
	示例:
	class Father{
		var name:String 
		var age:Int
		init(){							---构方1
			name = "xiaomin"
			age = 30
		}
		init(name:String){				---构方2. 多态. 
			self.init()
			self.name = name
			self.age = 30 				----所有指定构方必须初始化全部属性
		}
		convenience init(name:String,age:Int){	--便利构方3. 不能被override, 但可被子类调用(子类初始化)
			self.init(name:name)
			self.age = age
		}
	}
	class Son:Father {
		var birth:String 
		override init(){			-- 重写init()要加override
			birth = "201611"		-- super.init()前子类属性要全部初始化
			super.init()
			name = "Yu Heng"		-- 父类实例化后, 才能修改继承来的属性
			age = 1
		}
		override convenience init(name:String) {	-----辅助.  子类重写变成便利, 孙类就不能再重写它了.
			self.init()								-----它不能调用super.init, 只能且必须调用self.init 
			self.name = name 
		}
	}
	let father = Father(name:"xiaomin",age:30)		--便利构方
	let son1 = Son()								---name:Yu Heng  子类已重写
	let son2 = Son(name:"玉衡")						---name:玉衡	 子类已重写, 且为便利构方了.
	let son3 = Son(name:"",age:1)					---调用父类的便利构方.
	
	
	
swift继承之初始化的特点: 安全
	基类中的init必须初始化全部属性, 继承类的所有init必须调用super.init且仍要初始化全部自身属性.
	基类和继承类中的convenience方法必须调用self.init再初始化. 
	继承链Chains 每层类都是安全的, 都会初始化链中所有属性.
	
	
	
7. 可失败初始方法: init?
	由于无效的参数值, 缺乏需要的外部条件等原因导致初始化失败.
	
	可在类,结构,枚举中可选地定义可失败方法, 使用init?定义.
	返回的类型是[可选类型], 可加条件返回nil.
	
	struct Rect{
		var width,height:Int 
		init(){
			width = 10,height =10 
		}
		init?(w:Int){						---要先有init()方法
			if w=0 { return nil }
			self.width = w
			self.height = 0 
		}
	}
	let a = Rect()
	let b = Rect(w:20)			---Rect? 20,10
	let c = Rect(w:0)			---Rect? : nil 
	

	
8. 可失败转为正常init:
   init? 中也可调用super/self.init(),  可被override (可为非失败的init())
   
	哪里有?哪就有!:
	let b = Rect(w:20)! 		--结果从?变为正常.
	

	
9. 可失败的枚举和原始值: rawValue
	enum Char {
		case A,B,C,D 
		init?(char:String){
			switch char {
				case "a": self = .A 
				case "b": self = .B
				default : return nil 
			}
		}
	}
	let a = Char(char:"a")		-- Char? A
	
	//原始值
	enum Char:Int {				---枚举值的类型Int
		case A = 1,B,C,D,E
	}
	let a = Char(rawValue:2)	--- Char? B
	

10. 必须的初始化: required
	修饰后, 子类必须重写此init,且仍要带required.
	class Person{
		required init(){		---如能明确初始化内容, 可不必加required的.
		}
	}
	class Son:Person{
		required init
	}
	
	--只要一个祖类构方是required,则所有子类,孙类重写init都要加required, 并且无法用final断掉.
	

	
11. 用闭包给属性赋初始值:
	格式:
	class Person {
		let name:String = {
			return "xiaomin"    --此时并没有初始化, {}内不能调用其他属性, 不能使用self.
		}()
	}
	好像没什么用啊

	
	
================= 反初始化  ====================================
deinit同init一样用， 只能用于class中。
虽然swift使用ARC帮助释放内存， 但使用自己的资源时，可能需要释放内存。
	比如class中打开文件和write,则在实例销毁前dealloc，需要关闭文件。

	deinit {
		—实例销毁前要做的处理。。。
	}




================ 自动引用计数 (ARC)=================================================
ARC只作用于类 reference Type, 结构和枚举是值类型不需要引用计数。

同ObjC，只要有活的引用此实例则实例就存在。 只要定义类实例到一个属性、常量、变量，
则此属性、常量、变量会生成strong引用于实例。 

1. ARC示例：
  class Person{
	var name:String
	init(name:String){
	    self.name = name
	    print(“”)
	}
	deinit {
	    print(“”)
	}
  }
  let p1:Person?
  p1 = Person(name:”xiao”)
  
  —let p2:Person? = p1		—这句话加上与不加上差别很大。p1为nil 还有p2呢。
  p1 = nil			
  p2 = nil			—最后所有references都为nil时，才会销毁，及销毁前deinit
  
  
  注意! 所有变量/常量引用向的都是 ()实例的对象.
  var num:Int = 0
  class Aa{
	deinit {
		print("Aa deinit \(num++)")
	}
  }
  var aa:Aa? = Aa()		--1.Aa()创建新实例, 2.aa变量引用已创建的实例
  aa = Aa()				--1.创建了新实例; 2.aa指向新实例; 3.之前的实例因无强引用,被销毁 print
  aa = Aa()				--同上, 之前实例无强引用销毁 print num++
  
  var bb:Aa? = aa 		--第2个变量指向实例 
  aa = nil 				
  bb = nil 				--两个之一断掉strong引用没反应, 全部断掉strong后, 实例销毁 print num++


2. 类与类之间的strong引用循环
	class Aaa{
		var b:Bbb?
		deinit { print(“aaa deinit”)}
	}
	class Bbb{
		var a:Aaa?
		deinit { print(“bbb deinit”) }
	}
	var aaa:Aaa? = Aaa()	
	var bbb:Bbb? = Bbb()		—此时生成Bbb()实例和bbb变量两个，bbb是引用Bbb()真实例。
	aaa!.b = bbb
	bbb!.a = aaa				---此时产生了引用循环: aaa变量引用bbb,bbb变量引用aaa.

	aaa = nil			—变量设为nil,是砍掉对真实例的引用，但Aaa(),Bbb()之间还产生引用呢。
	bbb = nil			—因此不会调用到deinit
	


3. 解决strong引用循环：
	swift提供两种方法：weak引用，unowned无主引用 

	都能解决两个类互相引用时不会产生strong循环。
	weak引用 可以不管它哪个阶段会无效为nil；weak必须是变量var确保运行时可以修改,不能weak常量.
	unowned引用 是永远不会为nil的，永远有值。

	
   weak引用：
		weak它不保存对象的strong引用,即引用计数不会+1 ;  它可以引用缺失的值 (nil)
		
	接上面:
		class Bbb{
			weak var a:Aaa?				---这样实例Aaa()与Bbb()之间是单向的A类变量指向B类了.
		}
		var aa:Aaa? = Aaa()			--- aa 强引用Aaa() 
		var bb:Bbb? = Bbb()			--- bb 强引用Bbb()
		aa!.b = bb 					--- aa.b 强引用Bbb()   ---两个引用to Bbb(),一个引用to Aaa()
		bb!.a = aa					-- bb.a 无strong
	-----------------------------------------------
		--1.先去掉两个引用的 Bbb()
		aa!.b = nil 
		bb = nil 			--此时,输出 "Bbb deini";   Aaa()完好
		
		--2.直接去掉一个引用的Aaa()
		aa = nil			---唯一强引用为nil, Aaa()销毁; aa.b也没有了,但有bb指向,Bbb()缺了一臂还活着.
		
		--3. bb和aa的顺序为空
		bb = nil 			--光这一句话无反应. 此时还有aa.b指向Bbb()
		aa = nil 			--aa为空导致Aaa()销毁; aa没有aa.b也没有了,加上bb为空Bbb()销毁,
							--按顺序打印: Aaa deinit
										  Bbb deinit 				
		--4. aa和bb的顺序为空
		aa = nil 			--此时Aaa()无引用,销毁,打印. aa.b也无附着,为空了
		bb = nil 			--Bbb()引用全为空了.
							--按顺序打印: Aaa deinit
										  Bbb deinit 	
										  
		--5. 不声明aa,只声明bb和bb.a,则:
		var bb:Bb? = Bb()		
		bb!.a = Aa()			--虽未设置nil,但此时Aa()还是销毁了,bb.a还是nil.  bb.a是weak引用啊,
								即使声明实例却无strong指向,声明后即销毁.
		
		
	总结:
		1. 所谓引用 是对实例的引用(实例是没有名字的), 而非变量对变量的引用.
			aa = Aaa();		--
			bb = aa; 		--指向Aaa()实例. Aaa()实例有名字吗??  当然没有
			aa = Aaa()		--aa指向另外一个Aaa()实例了.
							--aa能代表Aaa类吗?  不能, 是Aaa()实例能.
							
		2. 某实例引用变为空(aa=nil), 则不光aa指向实例减少引用, aa下所有变量指向实例的引用计数都减少.
			即aa=nil,则aa.bb也是nil了. 所以3,4顺序一样. 
			Aaa类变量强引用Bbb,则aa.b指向Bbb(), aa为空,aa.b也为空.
			
		3. weak变量赋值时创建实例, 则实例创建后销毁,此变量虽赋值却仍是nil.(看5)
   
   
   
   unowned引用:
	 无主引用被设定为永远有值(不能为nil), 类型声明不带?号. 
	 
	 weak变量赋值时创建实例, 它当时就销毁,变量还是nil.
	 unowned变量即使引用销毁, 也不能变成nil. 若此时调用unowned变量会报错. 
		无主引用只在确保引用在非空实例时才能使用(1.实例不销毁,2.销毁则换新实例吗)
   
    无主引用的使用场景: 
		仍是类与类间的strong引用循环.  无主的关键是,Xxx()创建实例直接赋给变量, 这样无名无主啦!
		
	示例,接上面:
		class Bbb{				--只修改Bbb类, weak变成unowned
			unowned var a:Aaa 		--不能为nil,不可为?. 
			init(a:Aaa) {
				self.a = a			--因此init里必须初始化完全
			}
			deinit {
				print("Bbb is deinit")
			}
		}
		var aa:Aaa? = Aaa()			--
		var bb:Bbb = Bbb(a:aa!)
		//bb.a = nil 					--unowned变量不能为空,报错.
		aa = nil 						--aa为空,Aaa()释放; aa.b为空,Bbb()释放.
									
		var aa!.b = Bbb(a:aa!)		    --为了不操作无主变量Bbb().aa, Bbb()实例化不赋给新属性(var,let)
											而是直接赋给对象的变量.
		
		
4. 闭包的strong引用循环
	闭包也是引用类型!  
	当class中属性为闭包, 闭包中又调用了class其他属性. 此时生成strong引用循环.
	class Person {
		var name:String = "xiao"
		lazy var descript:()->String = {			--调用self属性的闭包必须使用lazy
			return "my name is \(self.name)"		--调用了self.property
		}
		deinit {
			print(" person deinit")
		}
	}
	
	var ps:Person? = Person()
	ps!.descript = {							--此时闭包是赋值而非调用,即并未实例化.
		return "hello, I'm \(ps!.name)"
	}
	
	// ps = nil					--此时无strong循环, ps会销毁.
	print(ps!.descript()) 		--使用括号()调用后的lazy闭包才真正实例化的.
	ps = nil					--已生成引用循环, nil后不会销毁.
	
	--产生了ps和closure()两个实例, strong引用循环.


5. 解决闭包的强引用循环

	1. 定义一个捕获列表
	lazy var someClosure: (Int, String) -> String = {
		[unowned self, weak delegate = self.delegate!] (index: Int, stringToProcess: String) -> String in
		//闭包体
	}
	或者无参数时:
	lazy var someClosure: () -> String = {
		[unowned self, weak delegate = self.delegate!] in
		//闭包体
	}
	
	2. weak或者unowned引用
	闭包可能为nil时用weak, 不会为空时用unowned
	lazy var asHTML: () -> String = {[unowned self] in
		//闭包体
	}
	


=====================  可选的链  =================================
  就是用?.xx?.xx?.xx调用, 如果前面的是nil, 则直接返回nil
  
1. 代替强制打开
	对于可选的实例调用属性/方法:
	var ps:Person? = Person()
	var a = ps!.age 			--nil对象调用!.会报错, 所以person先实例
	现在是:
	var ps:Person?				--person现在是nil,   不能使用!.来调用
	var a = ps?.age				--能用?.调用,  不报错而是直接返回nil.
	
   
   
2. 可选链调用属性
	var ps:Person? = Person()
	ps?.dog = Dog()
	ps?.dog?.name = "wang cai" 			--类中dog属性和name属性之前都是定义为?型的.
	
	print("\(ps?.dog?.name)")		--可用?.来访问和设置
	
	
3. 可选链调用方法
	class Person{
		func say(){}
	}
	var ps:Person?
	if let a = ps?.say() { }	--此时let nil为false
	
	ps = Person()
	if let a = ps?.say() { }	--这样竟然通过
	
	
	赋值是否成功的判断:
	class Person{
		var dog:Dog?
	}
	var ps:Person? = Person()
	if (ps?.dog = dog2) != nil {		--必须括号后和nil比较. ( != 前后要有空格哦)
		//赋值成功, 而不是Nil.
	}
	
	
4. 可选链作用于下标
	Array,Dictionary 也能使用可选链下标
	
	var arr:[String]?
	arr = ["jack","Tom"]
	let first = arr?[0]
	
	
5. 多层调用
	obj?.property?.method()
	方法的可选型返回值
	obj?.property?.method()?.property......
	
	
	

=============== 异常处理 ================================
在ObjC中使用NSError处理异常


1. 展现和抛出异常
	swift中使用ErrorType空协议, ErrorType表明此类型可用来处理异常.
	枚举特别适合建立一组相关的异常条件:
	enum SomeError: ErrorType {
		case IndexOutOfRange
		case NullPointer(arg:Int)
		case FileNotFount
	}
	
	使用throw+枚举值来抛出异常, 来表明发生哪种异常和程序不能往下执行.
	throw SomeError.NullPointer(arg:5)
	
	
2. 处理异常
	swift中有4种方式处理异常
	1.继续抛出throws
	2.do-catch
	3.处理异常成可选值 
	4.维护异常不发生
	
	swift中异常处理形式同其他语言, 但机制不一样.
	它不会涉及打开call stack(计算昂贵的过程); 性能特性上throw和return差不多.

2.1 继续抛出:
	func mtdName(arg) throws ->String {}		--在参数与返回类型之间 
	func mtdName() throws { }					-- 只有throws , 没有java上的异常类型
	
	
2.2 do-catch:
	--即使用do-catch处理的方法也要throws,  不然会报exhaustive错误.
	class Person{
		func mtd1() throws {
			print("hello")
			throw SomeError.IndexOutOfRange				--抛出.   前后有代码
			print("end?")
		}
	}
	var p = Person()
	func test() throws {						--仍要有throws
		do {
			try p.mtd1()						--如果方法有返回值,可以 let a = try p.mtd1()
		} catch SomeError.IndexOutOfRange {	
			print("index out")
		} catch SomeError.NullPointer(let arg) {
			print("\(arg)")						---有参数的话, 参数还有使用的
		}
	}
	
	test()			--调用生效.  打印出hello和
	
	注意: 只用try的话, 只要方法调用则每一层方法都必须有throws. 要想不throws,则try?和try!
	
	
2.3 转换异常为nil: try?
	let x = try? mtd()    --即使mtd()无返回值, try?也会返回nil
	
	或者:
	let y:Int? 
	do {
		try mtd()
	} catch {
		y = nil 
	}
	
2.4 阻止异常向上传播:try!
	使用try!会终止throws抛出, 如方法真抛出了错误, 则直接报出运行时异常.
	let a = try! mtdName()
	
	
2.5 最后处理:defer   (同finally)
	除了异常后执行清理工作,  无异常情况也可以加. 
	不管遇到throw,还是continue/break,return, 它都会执行
	(同finally{ conn.close() })
	
	--但好像defer{}要写在return,throw等的前面.
	
	func test() {
		print("aaa")
		defer {
			print("bbb")
		}
		print("ccc")
	}
	--打印aaa,ccc,bbb
	
	

=============== 类型判断和转换 is as  ================================

用来判断一个实例的类型,  or在类层级上判断是否为某类的父类or子类.

1. 类型层级同数组
	var xiaos = [
		Father(),Son(),GrandSon()
	];
	let son = xiaos[1]
	print(son.birth)		--报错, 说Father里没有成员birth
	
	
	---储存在数组里的实例仍然是Father()和Son(),但是遍历数组后取回的对象类型就是Father(最顶层那个).

	
	
2. 类型检查: is
	is检查实例是否属于此类型(父类,自身) 
	
	for item in xiaos {
		if item is Person {  几个 Person }			
		if item is Son {  几个Son }					
	}
	
	-- is 是属于的关系, 实例 is 父爷类/自身 
	-- 另见下面 Any 
	
	
	
3. 向下转换类型: as?,as!
	let son = xiaos[1] as!Son 		-- 强制转换,用!,成功则为non可选类型, 失败则报错
	print(son.birth)
	
	let son = xiaos[1] as?Son 		-- 不强制转换, 用?,成功则为 可选类型, 失败则返回nil.
	print(son!.birth) 				-- 可选类型 

	
	用 as?+if来判断转换:
	if let item = xiaos[0] as? Son {		--此时失败, 但返回nil来赋值, if会为false
	} 
	
	
	
4.  对任意对象进行转换:any,anyObject
	anyObject可代表 任意类对象
	any 可代表任意类型,包括函数类型
	
	使用any/anyObject只有明确需要提供的行为时再用, 具体的类型才是更好的.
	
  AnyObject:
	使用cocoa时, 有时会获得AnyObject型数组.
	let arr:[AnyObject] = [Son(),Son()]
	let son = arr[0] as! Son 		--因为明确知道元素都是Son, 所以可以用!来转换.

  Any:
	let arr = [Any]()				--哇, 包含任意类型的数组
	arr.append(10)
	arr.append(0.123)
	arr.append("hello")
	arr.append((1,2,3))									--tuple元组
	arr.append(Person(name:"xiaomin"))					--引用类型 
	arr.append( {()->String in return "hello"} )		--闭包
	
	可以在遍历杂类数组时用is,as来判断类型:
	for value in arr {
		switch value {
			case let dbl as Double where dbl > 0:	--- 用as时不加!?和=
			case is String :						--- 用is时不能写左边的.
			case let ps as Person:
			case let mtd as ()->String : print(mtd())
			
		}
	}
	
	--我靠, 在switch里面好多都省略了.  用if最完整
	let mtd = arr[5] as! ()->String   	
	mtd()
	
	

=============== 嵌套类型 ================================
即class,struct,enum的多层互相嵌套. 
示例
	struct Test {
		enum Enum0:Int {								--嵌套声明enum
			case A=1,B,C,D,E,F 
			case Jack,Tom,Hellen
			struct Values{								--enum中嵌套声明struct
				var aa:Int,bb:Int?
			}
			var value:Values{							--Int型enum中定义内部声明的Struct类型的变量
				switch self {
					case Jack :return  Values(aa:1,bb:1)
					case A,B,C,D,E,F: return Values(aa:0,bb:0)
					default: return Values(aa:10,bb:10)
				}
			}
		}
		var aa:Int 
		var enum0:Enum0 								--struct中定义内部声明的enum的变量
		var description:String{
			return "my description"
		}
	}
	var test = Test(aa:1,enum0:.Jack) 			--内部声明的enum在定义变量时也用.调用.
	let a = test.enum0.value.aa 				--嵌套的调用
	
	let raw = Test.Enum0.Jack.rawValue 			--用类型名调用




	
=================== 扩展 ========================================
同ObjC一样, 无法修改源代码的情况下可扩展类,struct,enum,协议中的类型.
不同于ObjC,swift中不需要新扩展名,直接extend	

通过扩展可以:
	1. 添加计算型属性(包括static)
	2. 定义新方法(包括static),  但方法不能override存在的方法
	3. 添加新构造方法
	4. 添加新下标
	5. 定义和使用新嵌套类型
	6. 让它实现新协议.
	
	注意: 如扩展新方法, 则所有实例都可使用新方法. 即使实例在扩展代码之前.

1. 扩展语法
	extension SomeType{
	}
	
	使实现新协议:
	extension SomeType: protocol1, protocol2 {
	}

	
2. 计算型属性扩展:
	示例: 扩展系统内置
	extension Double {
		var 万: Double{ return self*1000}
		var 折: Double{ return self/10 }
	}
	var money = 1.5.万		-- 1_5000 , 调用时加.点
	var sale = 8.5.折			-- 0.9
	
	
	注意: 1.已有的计算属性不能override, 否则报错.
		2. 可扩展setter方法.(上面的是get简写)
		3. 扩展只能添加计算型属性, 不能扩储存型属性和给属性添加监听(观察者)
	
	
	
3. 构造方法扩展
	class中的构造方法只能扩展convenience构方; 指定构方和deinit不能扩展的. 
	extension Person{
		convenience init(name:String){				--只能扩展便利构方
			self.init()								--便利里必须要调用指定构方的.
			self.name = name 
		}
	}
	
	如扩展值类型, 必须要为所有储存属性提供默认值, 且不能添加新属性!.
	struct Rect{
		var width,height:Int 
	}
	extension Rect{
		init(_ w:Int) {
			self.width = w 
			self.height = w					--值类型构方要保证初始化所有.
		}
	}
	var r1 = Rect(width:1,height:2)			--原始的, 使用属性名初始化
	var r2 = Rect(6)						--扩展后的.
	

4. 方法扩展:
	示例: 扩展系统内置
	extension Int{
		func hello(){
			print("hello:\(self)")
		}
	}
	7001667.hello()		-- hello:7001667
	
	值类型调用self和成员属性时,要用mutating. (class不需要)
	extension Int{
		mutating func abc() {		
			self = self+10 			--方法无返回值, 只会修改self.
		}
	}
	var num = 7 
	num.abc()				
	let aa = num			--aa==10		Tip:扩展Int生成随机数, 多少位数....
	
	
5. 下标扩展
	示例: 还是系统内置
	extension Int{
		subscript(index:Int)->Int{	
			let len = "\(self)".characters.count			--返回index所在整数中的位数
			if index > len {
				return -1
			} else {
				return len - index 	
			}
		}
	}
	let len = 123456[2]		--4 
	
	
	
6. 内置类型扩展
	示例: 还是系统内置
	extension Int {
		enum Kind{
			case Nega,Zero,Posi			--判断Int是正数负数
		}
		var kind:Kind{
			switch self {
				case .Nega: 
				case .Zero:
				case .Posi:
			}
		}
	}
	let a = -10 
	if a.kind == .Nega {
	}
	

	
======================== 协议 protocol ====================================
	协议定义了一个蓝图,规定了其中的属性,方法和其他一些要求.
	协议可被class,struct,enum采用.  类型满足协议要求被称为"遵守这个协议"
	
	协议也可扩展协议
	
1. 定义,实现协议
	protocol SomeProt {
	}
	
	struct SomeStruct: FirstProtocol, SecondProtocol {	--结构体实现协议
	}
	class SomeClass: SuperClass,SomeProtocol {		--继承父类和实现协议方式一样.
	}
	
	注: swift中没有抽象类, 没有继承时必须重写的方法.(init构方可加required强制重写)
		某类要必须实现某方法,则必须遵守某协议.
	
	
	
2. 协议属性的实现
	协议中只定义属性的名字和类型, 不管你是储存型还是计算型.
	
	要指定属性是get或者get set; get在实例化后不能修改了,get set可以修改.
	如是get+set,则实现时不可以是常量,也不能是readOnly计算型属性. 可为普通储存属性,实例后可修改.
	如是get,则可以是任意类型属性, 实例后不可修改的. (计算型也可选set方法的,但set中只能修改其他属性). 
	
	protocol SomeProtocol{
		var aa:Int {get set }	--则实现类型中必须有set方法.   {}中get,set中间是空格
		var bb:String {get}		--则可选set方法. 可为任意类型属性,且可定义时不初始值,可以可读,常量 
	}
	struct SomeStruct:SomeProtocol {
		var aa:Int{							--注意不能带=号.
			get{ return 10}
			set{ self.aa = newValue }   	--set方法.  如协议get型则可选的set只能修改其他属性
		}
		var bb:String						--非set方法, 可定义时无初始值.
		var cc:String						--结构自身属性.
	}
	let str:SomeProtocol = SomeStruct(bb:"hi",cc:"hi")		--type直接是协议, 实例是struct()
	str.aa = 20 
	//str.bb = ""	--get型的修改会报错.
		
	注意: struct计算型性实例化不要加进(). 储存变量实例化时都要加进()(不管声明时是否初始化过).
	
	
	
  static属性,只能由class来遵守了
	protocol SomeProto{
		static var cc:Int{get}					--static属性
	}
	class Person:SomeProt{
		static var num:Int = 10
	}
	let num = Person.num 			--静态调用  类名.属性	
	
	
	
3. 协议方法的实现
	可定义init构造方法和类型方法(static的).
	同java接口一样,名称+参数.  然而,参数默认值是不可以加的
	
	protocol SomeProtocol{
		func abc()->String 					
		func bcd() 				--无返回时
	}
	同类型属性一样, 类型方法前缀static   (类型XX vs 实例XX,即是否static..)
		static func abc()->String 
	
	
	
4. mutating值类型方法
	在struct,enum中方法是值类型, 方法体中不能修改self.属性.  mutating func可以修改
	mutating的协议方法在class中不写mutating; 在struct,enum中实现要写.
	protocol Pro1{
		var name:String{get set}
		mutating func abc(name:String)
	}
	class Per1:Pro1{
		var name:String = ""
		func abc(name:String) {
			self.name = name			--class方法可修改成员属性; struct,enum的必须mutating才能修改.
		}
	}
	
	
5. 协议中init构造方法
	实现协议init()时, 要加上required前缀,即所有子孙类必须重写此init(); 所有子孙类的Init()全要加required前缀 
	(官网说final的init方法不加required,好像required的不能改为final呀).
		
	protocol SomeProtocol{
		init(age:Int)
	}
	class Person:SomeProtocol {
		required init(age:Int) {
			super.init(age:age)
		}
	}
	class Son:Person{
		required override init(age:Int){    ---override可写可不写
			super.init(age:age)
		}
	}
	
	--协议中也可定义可失败构方failable, 即init?()
	
	
6.  接口作为类型
	 同java上,List类型的属性,返回值,参数等
	
	 var aa:SomeProtocol = SomeClass()
	 func abc(obj:SomeProtocol) -> SomeProtocol
	 
	 
	 
7. delegate 代理  -----------------------------------------------------
	是一种设计模式, 能让class,struct切换or代理其他类型对象的职责.
	实现类作为委托者.   代理可用来提供特定action,或检索外部源而不用考虑底层类型的来源.
	
	protocol 主体{
		func action()
	}
	protocol 委托{
		func  行为(arg:主体)
		func  行为2(arg:主体)		--参数调用另一protocol很重要. 配合class实现此协议来解耦.
	}
	
	class 功能:主体{
		var delegate:委托?				--可为nil.
		func action(){ 
			delegate?.行为(self)		--参数是协议类型, self类就实现它. 可选类型,调用要带?号.
			delegate?.行为2(self)
		}
	}
	
	class 委托一:委托{
		func 行为(arg:主体){}
		func 行为2(arg:主体){}
	}
	
	-------------------
	let delegate = 委托一()
	let act = 功能()
	act.delegate = delegate 
	act.action()					--最终行为执行
	
	act.delegate = 委托二()
	act.action()					--使用另一委托了.
	 
	 
	解说: '主体'的实现类方法体中调用'委托'的方法, 因delegate是可选类型,这里的处理和ObjC的不一样.
		ObjC中用if+是否实现此方法判断, 这里可加上if+nil判断, 只要不为nil肯定会实现协议中方法的.
		如果delegate为空, 则不会调用方法,此时应加上默认处理.
		
		关键上是两个协议, 主体要实现一个, 行为要实现一个; 行为的方法参数是主体协议, 这样才真解耦,
		主体可设置不同的行为(delegate), 而行为可被不同的主体调用(func mtd(arg:协议类型)).
		
	

8. 给已存在的类型添加遵守协议,并实现新属性,方法,下标 
	protocol SomeProtocol{
		func hello()
	}
	extension Dog:SomeProtocol{
		func hello{
			print("hello,my value is :\(self)")			--实验显示出错: 冗余实现协议 (即不加协议照样能扩展)
		}
	}
	
	如能扩展后, 则原类型也可变成新协议类型了
	var pro:SomeProtocol = Dog()
	pro.hello()
	
	
9. 协议继承
	形式同类继承,同类实现协议,都是:后用,号分隔
	protocol SomeProtocol: FirstProtocol,SecondProtocol {
	}
	
	
10. class才能用的协议:class
	protocol SomeProtocol: class, FirstProtocol {
	}
	
	使用class关键字放在协议:后的首位,后面则是可选的继承协议. 
	class才能用, struct,enum不能使用此协议了.
	
	
	
11. 协议合成<>
	属性类型, 参数类型要求为同时遵守多个协议时, 使用protocol<p1,p2..>来表达
	
	var delegage:protocol<UITableViewDelegate,UITableViewDataSource>
	
	func abc(dog:protocol<Animal,Loveable>) {}
	
	--它没有产生新协议, 只是要求同时遵守多个协议而已.
	
	
	
12. 协议的检查:is as any
	用is判断是否为此协议, 返回true/false 
	用as?强制转换为实际类型的可选类型, 失败返回nil
	用as!强制转换为实际类型, 失败则报错.

    用AnyObject让数组中放不同class对象
	用Any让,, 好吧,基本类型与协议无关

	
13. 可选的协议实现:@objc + optional
	@objc表示此协议or类可暴露给ObjC代码. 即使不需要和ObjC代码结合, 想要可选实现也要加@objc 
	@objc好像只能被ObjC的class或者@objc class使用.
	
	@objc protocol SomeProtocol{
		var name:String{get}
		func abc()
	}
	
	
	
14. 协议扩展
	可被扩展添加方法和属性. 且扩展协议方法时实现方法体.
	extension SomeProtocol {
		func abc()->String {
			print("xxx")
		}
	}
	
	--扩展后, 所有已实现此协议的类都可调用它, 不管是否在扩展前实例.

	
14.1  提供默认实现   --没看懂, 太少


14.2 协议扩展加上约束: where 	--不太会
	示例: 
	extension CollectionType where Generator.Element: TextRepresentable {	--Array遵守CollectionType协议
		var textualDescription: String {
			let itemsAsText = self.map { $0.textualDescription }		--$0是闭包默认参数名
			return "[" + itemsAsText.joinWithSeparator(", ") + "]"
		}
	}
	
	-- 扩展CollectionType协议,让其中元素来遵守某协议. 然后扩展的方法调用元素遵守的协议中的方法...


	
	
=================== 泛型 ========================================
泛型可写出灵活,可重用函数和类型. 泛型的代码可避免重复,且表达意图明确,抽象的方式.

泛型是swift很强大的特性,大多数标准库都用了泛型构建. Array,Dictionary就是用了泛型



1. 泛型解决的问题
	相同类型的处理. 
	示例:
	func swapValue<T>(inout a: T, inout _ b: T) {	 --两个变量调换值. (注意:swap()是标准库名,换swapXX())
		let temp = a;
		a = b;
		b = temp;			--使用T了, 不管什么类型(ab要相同哦)的调换都可用此方法
	}
	
	--如转换Double,String等就不用再写swapDouble, swapString....
	var a = 10;
	var b = 8;
	swapValue(&a,&b)		--inout修饰的参数, 在调用时要加&
	
	var s1 = "hello"
	var s2 = "hi"
	swapValue(&s1,&s2)
	
	swapValue(dog1,dog2)
	
	
2. 泛型参数的类型名字:T,Key...
	上面的<T>可以是其他名字. 只要后面的对应上就行:  mtd<XM123>(inout a:XM123)
	还有Dictionary<Key,Value>, Array<Element>, 
	仅是定义名, 调用时无关.

	
	
3. 自定义泛型类型:
	swift允许自定义泛型,有些class/struct/enum可使用任意类型. 如Array[T],Dictionary<K,V>
	
	示例:自定义堆Stack<>  --push,pop后进后出
	
	struct Stack<Element>{
		var elements = [Element]()					---<>中的类型名, 在内部直接使用.
		mutating func push(item:Element){
			elements.append(item)
		}
		mutating func pop()-> Element {				--为防Array删完,可用?号.
			return  elements.removeLast()			--return elements.isEmply ? nil : ...
		}
	}
	
	var stack1 = Stack<String>()			--新泛型的格式:  name<X>()
	
	var stack2 = Stack<Any>()				--存放任意类型数据Any! AnyObject
	stack2.push("hello")
	stack2.push(123)
	stack2.push((1,2,3,4))
	stack2.push(()->String{return "hello"})		--闭包
	
	
4. 扩展一个泛型
	扩展时原自定义名字仍能使用(如T,Element)
	extension Stack{		--这里就不用写<Element>了
		var firstItem:Element? {
			return items.isEmpty ? nil : items[items.count-1]
		}
	}
	
	
5. 泛型类型约束
	在func的参数中添加约束,必须继承某class,或实现某protocol. (Dictionary的key就约束为必须hashable.)
	
	struck Stack<T,U>{										--此时仍和原先一样,
		var someProp:T 				
		func mtd<T:Class2,U:Protocol1>(a:[T],_ b:U){  }		--约束放在func中的
	}
	
	1.先写一个继承结构.
	class Person{ 								
		var work:String 
		init(work:String){
			self.work = work
		}
	}
	class Nurse:Person{}
	class Teacher:Person{}
	var nurse = Nurse(work:"Nurse")
	var teacher = Teacher(work:"Teacher")
	
	2. 自定义泛型.
	struct Worker<T>{
		var ps:T							--此属性没有意义. 只为实例化时有属性才不报错.
		func desc<T:Person>(p:T){			--在()前加上<>来进行约束.
			print(p.work) 
		}
	}
	var wk = Worker<Person>(ps:Teacher)		--
	wk.desc(p:Nurse)						--
	
	注意: 在最后实例化时, <>中不能加协议,父类是可以的.
	
	
	
6. 泛型之protocol的关联类型: associatedtype
	在声明协议时, 可以一个or多个自定义类型(关联类型), 此类型能被用作方法参数类型等, 
	而等到实现协议时再确定类型是啥. 用typealias来把此关联类型指向为真实类型.
	
	protocol SomeProtocol{
		associatedtype  itemType					--无类型, 仅占位类型名.  注意:此不是属性
		var arr:[itemType]{get}					--数组类型
		mutating func append(item: itemType)	--参数类型 
	}
	
	struct IntStruct:SomeProtocol{
		typealias itemType = Int			--用=号来定类型
		var arr:[itemType] = []					--实质是Int数组
		mutating func append(item:itemType){	--Int参数
			arr.append(item)
		}
	}
	
	struct DogStruct:SomeProtocol{
		typealias itemType =  Dog 
		var arr:[itemType] = []					--实质是Dog 数组
		mutating func append(item:itemType){	--Dog参数
			arr.append(item)
		}
	}
	
	
  关联类型被实现类型中 显式泛型代替:
	使用了associatedtype的地方, 使用实现类型的<T>
	
	struct SomeStruct<T>:SomeProtocol{
		var arr:[T]						--协议中是itemType的地方, 在这里使用<>显式泛型.
		mutating func append(item:T)
	}
	
	
	
7. 关联类型where子句
	where能要求关联类型必须遵守另一协议, 两个关联类型必须相等(类型一致)
	
	func mtd<T1:Pro1,T2:Pro1 								--1.两个泛型T1,T2. 都遵守Pro1协议
				where T1.itemType==T2.itemType,				--2.两泛型中实现的itemType的类型一致
					T1.itemType:Pro2>(a:T1,b:T2){			--3.T1实现的itemType要遵守另一协议
	}
	
	
	
	
	
=========================== 访问控制 ===========================================
访问控制可限制其他模块or文件中的代码访问现文件中的代码.
此特性能隐藏实现细节, 和指定外部访问的优先接口.

	在访问控制中,模块中的属性,函数,结构等类型统称为 实体Entities

	
1. 模块和源文件
	模块(module)是一个单元,被import的都是单独的模块.
	
		Xcode中每个build target(如应用程序包,框架)在swift里都是单独的模块.
		可以把代码组合到一起成为一个新framework----用来压缩代码和多个程序重用.
	
	源文件-- 单一文件啊


	
2. 访问级别:3种
	public			
	internal (内部的)   只能此模块内的所有代码访问.  import时不能访问,即外部模块不能访问.
	private				只能同一源文件中使用,不同class间也能调用. 可以隐藏特定功能的实现细节.
						当extension在外部文件中时, 不能访问原类型的private成员.

	--默认级别:internal (所有成员)
	--如只在singleApp里用用, 则不需要public. internal够用了.
	--如代码组合成模块, 则成为framework啦,成为API啦. 一定要public把接口放开给import你的模块调用.
	--单元测试:Unit Test Target,可以访问internal的,  外部模块引用后使用@testable可以测试.
	
	
3. 访问控制示例:
	public class XX 
	internal class Xxx
	private class Xxx			--private类只能在源文件中用作private属性,方法参数等.
	
	private var name:String 
	internal let age = 30
	private func mtd(){}
	
	
4. 子类 
	子类的级别不能比父类高,但是子类可对父类成员override重写成级别更高的成员.
	public class Father{
		private var name:String 				--私有成员
		private mtd(){}
	}
	internal class Son{
		override internal var name:String		--重写成内部成员
		override internal mtd(){
			super.mtd()							--private成员也能被其他类调用,必须在同一文件中.
		}
	}
	
	
5. 属性的get/set的访问控制
	属性即使没写get,set方法,默认都是internal的.
	struct Test{
		private(set) var count = 0 			--源文件外,就不可以.count=5直接set了. 注意这里的private仅是修饰set方法的. count属性仍是internal级别.
		func mtd(){
			count++								--本文件中, 无视private的
		}
	}
	
	public struct Test{
		public private(set) var count = 0		--public的属性, private的set方法.
	}


6. 构造方法
	默认构造方法init()的级别与它返回的级别一致,public的除外. 
	class的构方是internal; 
	private Struct的构方也private; 
	public class的构方是internal的, 如想提供public init()无参构方, 则必须手动写一个public的.
	
	
7. struct的默认构方
	struct的默认构方是成员逐一的.  如任一成员是private则默认构方是private, 否则是internal的.
	如想要public的成员逐一构方, 则手动加上.
	
	
	
8. 协议 
	协议里的每项成员的级别都与协议本身一致, 里面成员不能单独设置的.
	如定义public协议,则实现类的成员也会是public
	

	
	
	
================== 高级操作 =================================
有些了解就行了.

1. 按位操作, ~, & | ^ >> <<

2. 溢出操作
	当Int8之类赋过大的值时报错.
	&+, &-,&*
	
	var num = Int8.max 
	num = num &+ 1					--这样不报错, 按位变成0
	
	
3. 	操作符函数:
	class和struct可实现操作符函数. 如 obj+obj2;				--在playground里不能用,要文件中
	struct Rect{
		var width=0,height=0
	}
	func + (r1:Rect,r2:Rect) ->Rect {
		return Rect(width:r1.width + r2.width,   height:r1.height + r2.height)
	}

	var r1 = Rect(width:3,height:3)
	var r2 = Rect(width:6,height:6)
	var r3 = r1 + r2 					---两个实例直接+-*/了.   不影响操作符的正常操作
	
	
4. 操作符前缀,后缀
	同上 
	func - (r:Rect)->Rect{
		return Rect(w:-r.w, h:-r.h)
	}
	var r4 = -r1					--负对象, 则 r4:(-3,-3)
	
	
5. 综合操作符:
	同上, 如+= , ==
	r3 += r1 						--r3 = (12,12)
	
	let b = r2 == r1				--按内部内容全等返回bool
	
	
	
6. 自定义操作符: operator
	除现有组合操作符之外, 新加的组合.  如 a +-*/ b ,   a +-+- b ,  -!-a ...
	
	新操作符定义在全局范围的, 使用operator关键词, 加上prefix,postfix,infix(前后中缀).
	prefix operator func +++ (inout a:Rect)->Rect{}
	let r6 = +++r3 
	
	
	中缀的参数名要是left,right:
	infix operator +- (left:Rect,right:Rect) -> Rect {
	}
	
	let r7 = r3 +- r4 
	
	
==================== 官网记录 End ================================================
